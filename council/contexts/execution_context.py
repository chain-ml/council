import abc
import logging
from typing import Any, Dict, List, Optional, Sequence, Callable, Iterable, Mapping

import more_itertools
from typing_extensions import TypeGuard

from more_itertools import first

from .budget import Budget
from .messages import ChatMessage, ScoredChatMessage, ChatMessageKind
from .cancellation_token import CancellationToken
from council.utils import Option
from ..monitors import ExecutionLog, Monitored, ExecutionLogEntry

logger = logging.getLogger(__name__)


class MessageCollection(abc.ABC):
    """
    Base class to manage collection of :class:`ChatMessage`
    """

    @property
    @abc.abstractmethod
    def messages(self) -> Iterable[ChatMessage]:
        """
        Iterates over the collection of messages, in the order they appear in the context

        Returns:
            Iterable[ChatMessage]
        """
        pass

    @property
    @abc.abstractmethod
    def reversed(self) -> Iterable[ChatMessage]:
        """
        Iterates over the collection of messages, in reversed order

        Returns:
             Iterable[ChatMessage]
        """
        pass

    @property
    def last_message(self) -> Optional[ChatMessage]:
        """
        Returns the last message, if any, otherwise `None`.

        Returns:
            Optional[ChatMessage]:
        """
        return first(self.reversed, None)

    @property
    def try_last_message(self) -> Option[ChatMessage]:
        """
        Returns the last message, wrapped into an :class:`Option`

        Returns:
             Option[ChatMessage]:
        """
        return Option(self.last_message)

    @property
    def last_user_message(self) -> Optional[ChatMessage]:
        """
        Returns the last message of kind :attr:`ChatMessageKind.User`, if any, otherwise `None`

        Returns:
            Optional[ChatMessage]:
        """
        return self._last_message_filter(self.message_kind_predicate(ChatMessageKind.User))

    @property
    def try_last_user_message(self) -> Option[ChatMessage]:
        """
        Returns the last message of kind :attr:`ChatMessageKind.User, wrapped into an :class:`Option`

        Returns:
            Option[ChatMessage]:
        """
        return Option(self.last_user_message)

    @property
    def last_agent_message(self) -> Optional[ChatMessage]:
        """
        Returns the last message of kind :attr:`ChatMessageKind.Agent`, if any, otherwise `None`

        Returns:
            Optional[ChatMessage]:
        """
        return self._last_message_filter(self.message_kind_predicate(ChatMessageKind.Agent))

    @property
    def try_last_agent_message(self) -> Option[ChatMessage]:
        """
        Returns the last message of kind :attr:`ChatMessageKind.Agent` wrapped into an :class:`Option`

        Returns:
            Option[ChatMessage]
        """
        return Option(self.last_agent_message)

    def last_message_from_skill(self, skill_name: str) -> Optional[ChatMessage]:
        """
        Returns the last message generated by a given skill, if any, otherwise `None`

        Parameters:
             skill_name(str): Name of the skill

        Returns:
            Optional[ChatMessage]:
        """

        def predicate(message: ChatMessage):
            return message.is_of_kind(ChatMessageKind.Skill) and message.is_from_source(skill_name)

        return self._last_message_filter(predicate)

    def try_last_message_from_skill(self, skill_name: str) -> Option[ChatMessage]:
        """
        Returns the last message generated by a given skill, wrapped into an :class:`Option`

        Parameters:
             skill_name(str): Name of the skill

        Returns:
            Option[ChatMessage]:
        """

        return Option(self.last_message_from_skill(skill_name))

    def _last_message_filter(self, predicate: Callable[[ChatMessage], bool]) -> Optional[ChatMessage]:
        def typeguard_predicate(message: ChatMessage) -> TypeGuard[Optional[ChatMessage]]:
            return isinstance(message, ChatMessage) and predicate(message)

        return first(filter(typeguard_predicate, self.reversed), None)

    @staticmethod
    def message_kind_predicate(kind: ChatMessageKind) -> Callable[[ChatMessage], bool]:
        return lambda m: m.is_of_kind(kind)


class CompositeMessageCollection(MessageCollection):
    _collections: List[MessageCollection]

    def __init__(self, collections: List[MessageCollection]):
        self._collections = collections

    @property
    def messages(self) -> Iterable[ChatMessage]:
        for collection in self._collections:
            for message in collection.messages:
                yield message

    @property
    def reversed(self) -> Iterable[ChatMessage]:
        for collection in reversed(self._collections):
            for message in collection.reversed:
                yield message


class MessageList(MessageCollection):
    """
    represents the history of messages exchanged between the user and the :class:`.Agent`
    """

    _messages: List[ChatMessage] = []

    def __init__(self, messages: Optional[Iterable[ChatMessage]] = None):
        """
        initialize a new instance
        """

        self._messages = []
        if messages is not None:
            self._messages.extend(messages)

    @property
    def messages(self) -> Iterable[ChatMessage]:
        return self._messages

    @property
    def reversed(self) -> Iterable[ChatMessage]:
        return reversed(self._messages)

    def add_user_message(self, message: str):
        """
        adds a user :class:`ChatMessage` into the history

        Arguments:
            message (str): a text message
        """

        self._messages.append(ChatMessage.user(message))

    def add_agent_message(self, message: str, data: Any = None):
        """
        adds an agent class:`ChatMessage` into the history

        Arguments:
            message (str): a text message
            data (Any): some data, if any
        """

        self._messages.append(ChatMessage.agent(message, data))

    def add_message(self, message: ChatMessage):
        self._messages.append(message)

    def add_messages(self, messages: Iterable[ChatMessage]):
        self._messages.extend(messages)


class MonitoredMessageList(MessageCollection):
    def __init__(self, message_list: MessageList):
        self._inner = message_list

    @property
    def messages(self) -> Iterable[ChatMessage]:
        return self._inner.messages

    @property
    def reversed(self) -> Iterable[ChatMessage]:
        return self._inner.reversed

    def append(self, message: ChatMessage, log_entry: ExecutionLogEntry):
        log_entry.log_message(message)
        self._inner.add_message(message)


class ChatHistory(MessageList):
    @staticmethod
    def from_user_message(message: str) -> "ChatHistory":
        history = ChatHistory()
        history.add_user_message(message=message)
        return history


class ExecutionContext:
    _executionLog: ExecutionLog
    _entry: ExecutionLogEntry

    def __init__(self, execution_log: Optional[ExecutionLog] = None, path: str = ""):
        self._executionLog = execution_log or ExecutionLog()
        self._entry = self._executionLog.new_entry(path)

    def _new_path(self, monitored: Monitored, method: str):
        result = monitored.name if self._entry.source == "" else f"{self._entry.source}/{monitored.name}"
        if method != "":
            result = f"{result}.{method}"
        return result

    def new_for(self, monitored: Monitored, method: str = "") -> "ExecutionContext":
        return ExecutionContext(self._executionLog, self._new_path(monitored, method))

    @property
    def entry(self) -> ExecutionLogEntry:
        return self._entry


class AgentIterationContextStore:
    _chains: Dict[str, MonitoredMessageList]
    _evaluator: List[ScoredChatMessage]

    def __init__(self):
        self._chains = {}
        self._evaluator = []

    @property
    def chains(self) -> Mapping[str, MessageCollection]:
        return self._chains

    @property
    def evaluator(self) -> List[ScoredChatMessage]:
        return self._evaluator

    def ensure_chain_exists(self, name: str):
        self._chains[name] = MonitoredMessageList(MessageList())

    def append_to_chain(self, chain: str, message: ChatMessage, log_entry: ExecutionLogEntry):
        self._chains[chain].append(message, log_entry)


class AgentContextStore:
    def __init__(self, chat_history: ChatHistory):
        self._cancellation_token = CancellationToken()
        self._chat_history = chat_history
        self._iterations: List[AgentIterationContextStore] = []
        self._log = ExecutionLog()

        # to be deprecated
        self._evaluation_history: List[List[ScoredChatMessage]] = []

    @property
    def cancellation_token(self) -> CancellationToken:
        return self._cancellation_token

    @property
    def chat_history(self) -> ChatHistory:
        return self._chat_history

    @property
    def iterations(self) -> Sequence[AgentIterationContextStore]:
        return self._iterations

    @property
    def current_iteration(self) -> AgentIterationContextStore:
        return self._iterations[-1]

    @property
    def execution_log(self) -> ExecutionLog:
        return self._log

    def new_iteration(self):
        iteration = AgentIterationContextStore()
        self._iterations.append(iteration)
        self._evaluation_history.append(iteration.evaluator)

    def chain_iterations(self, name: str) -> Iterable[MessageCollection]:
        default = MessageList()
        for iteration in self._iterations:
            yield iteration.chains.get(name, default)

    @property
    def evaluation_history(self) -> Sequence[List[ScoredChatMessage]]:
        return self._evaluation_history


class ContextBase:
    def __init__(self, store: AgentContextStore, execution_context: ExecutionContext):
        self._store = store
        self._execution_context = execution_context

    @property
    def iteration_count(self) -> int:
        return len(self._store.iterations)

    @property
    def log_entry(self) -> ExecutionLogEntry:
        return self._execution_context.entry

    @property
    def chat_history(self) -> ChatHistory:
        return self._store.chat_history

    @property
    def chatHistory(self) -> ChatHistory:
        return self.chat_history

    def __enter__(self):
        self.log_entry.__enter__()
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        self.log_entry.__exit__(exc_type, exc_val, exc_tb)

    def new_log_entry(self, monitored: Monitored) -> ExecutionLogEntry:
        return self._execution_context.new_for(monitored).entry


class AgentContext(ContextBase):
    def __init__(self, store: AgentContextStore, execution_context: ExecutionContext):
        super().__init__(store, execution_context)

    @staticmethod
    def empty() -> "AgentContext":
        return AgentContext.from_chat_history(ChatHistory())

    @staticmethod
    def from_chat_history(chat_history: ChatHistory) -> "AgentContext":
        store = AgentContextStore(chat_history)
        return AgentContext(store, ExecutionContext(store.execution_log, "agent"))

    @staticmethod
    def from_user_message(message: str) -> "AgentContext":
        return AgentContext.from_chat_history(ChatHistory.from_user_message(message))

    def new_agent_context_for(self, monitored: Monitored, method: str = "") -> "AgentContext":
        return AgentContext(self._store, self._execution_context.new_for(monitored, method))

    def new_iteration(self):
        self._store.new_iteration()

    @property
    def chains(self) -> Iterable[MessageCollection]:
        return self._store.current_iteration.chains.values()

    @property
    def evaluation(self) -> List[ScoredChatMessage]:
        return self._store.current_iteration.evaluator

    @property
    def evaluationHistory(self) -> Sequence[List[ScoredChatMessage]]:
        return self._store.evaluation_history

    def set_evaluation(self, messages: List[ScoredChatMessage]):
        self._store.current_iteration.evaluator.extend(messages)


class ChainContext(ContextBase, MessageCollection):
    def __init__(
        self,
        store: AgentContextStore,
        execution_context: ExecutionContext,
        name: str,
        budget: Budget,
        messages: Optional[Iterable[ChatMessage]] = None,
    ):
        super().__init__(store, execution_context)
        self._name = name
        self._budget = budget
        self._current_messages = MessageList()
        self._previous_messages = MessageList(messages)

        self._current_iteration_messages = CompositeMessageCollection([self._previous_messages, self._current_messages])
        self._previous_iteration_messages = CompositeMessageCollection(
            list(self._store.chain_iterations(self._name))[:-1]
        )
        self._all_iteration_messages = CompositeMessageCollection(
            [self._previous_iteration_messages, self._current_iteration_messages]
        )
        self._all_messages = CompositeMessageCollection([self.chat_history, self._all_iteration_messages])

    @property
    def cancellation_token(self) -> CancellationToken:
        return self._store.cancellation_token

    @property
    def budget(self) -> Budget:
        return self._budget

    @property
    def messages(self) -> Iterable[ChatMessage]:
        return self._all_messages.messages

    @property
    def reversed(self) -> Iterable[ChatMessage]:
        return self._all_messages.reversed

    @property
    def chain_histories(self) -> Iterable[MessageCollection]:
        for item in self._store.iterations:
            chain = item.chains.get(self._name)
            if chain is not None:
                yield chain

    @property
    def previous_messages(self) -> Iterable[ChatMessage]:
        return self._previous_messages.messages

    @property
    def current_messages(self) -> Iterable[ChatMessage]:
        return self._current_messages.messages

    @property
    def current(self) -> MessageCollection:
        """
        Returns the :class:`ChainHistory` to be used for the current execution of a :class:`.Chain`

        Returns:
            ChainHistory: the chain history
        """
        return self._current_iteration_messages

    @staticmethod
    def from_agent_context(context: AgentContext, monitored: Monitored, name: str, budget: Budget):
        context._store.current_iteration.ensure_chain_exists(name)
        return ChainContext(context._store, context._execution_context.new_for(monitored), name, budget)

    def fork_for(self, monitored: Monitored, budget: Optional[Budget] = None) -> "ChainContext":
        return ChainContext(
            self._store,
            self._execution_context.new_for(monitored),
            self._name,
            budget or self._budget.remaining(),
            more_itertools.flatten([self._previous_messages.messages, self._current_messages.messages]),
        )

    def should_stop(self) -> bool:
        if self._budget.is_expired():
            logger.debug('message="stopping" reason="budget expired"')
            return True
        if self.cancellation_token.cancelled:
            logger.debug('message="stopping" reason="cancellation token is set"')
            return True

        return False

    def merge(self, contexts: List["ChainContext"]):
        for context in contexts:
            self._current_messages.add_messages(context._current_messages.messages)

    def append(self, message: ChatMessage):
        self._current_messages.add_message(message)
        self._store.current_iteration.append_to_chain(self._name, message, self._execution_context.entry)

    def extend(self, messages: Iterable[ChatMessage]):
        for message in messages:
            self.append(message)

    @staticmethod
    def from_chat_history(history: ChatHistory) -> "ChainContext":
        from .budget import InfiniteBudget
        from ..mocks import MockMonitored

        context = AgentContext.from_chat_history(history)
        context.new_iteration()
        return ChainContext.from_agent_context(context, MockMonitored("mock chain"), "mock chain", InfiniteBudget())

    @staticmethod
    def from_user_message(message: str) -> "ChainContext":
        return ChainContext.from_chat_history(ChatHistory.from_user_message(message))

    @staticmethod
    def empty() -> "ChainContext":
        return ChainContext.from_chat_history(ChatHistory())


class IterationContext:
    """
    Provides context information when running inside a loop.
    """

    def __init__(self, index: int, value: Any):
        self._index = index
        self._value = value

    @property
    def index(self) -> int:
        """
        Returns the index of the current iteration

        Returns:
            int:
        """
        return self._index

    @property
    def value(self) -> Any:
        """
        Returns the value for the current iteration

        Returns:
            Any:
        """
        return self._value

    @staticmethod
    def empty() -> Option["IterationContext"]:
        return Option.none()

    @staticmethod
    def new(index: int, value: Any) -> Option["IterationContext"]:
        return Option.some(IterationContext(index, value))


class SkillContext(ChainContext):
    """
    Class representing the execution context of a :class:`.SkillBase`.
    """

    def __init__(
        self,
        store: AgentContextStore,
        execution_context: ExecutionContext,
        name: str,
        budget: Budget,
        messages: Iterable[ChatMessage],
        iteration: Option[IterationContext],
    ):
        super().__init__(store, execution_context, name, budget, messages)
        self._iteration = iteration

    @property
    def iteration(self) -> Option[IterationContext]:
        """
        The iteration context, if any.

        Returns:
            Option[IterationContext]: Some iteration context, if any, else :meth:`.Option.none`
        """
        return self._iteration

    @staticmethod
    def from_chain_context(context: ChainContext, iteration: Option[IterationContext]) -> "SkillContext":
        return SkillContext(
            context._store,
            context._execution_context,
            context._name,
            context.budget,
            context.current.messages,
            iteration,
        )


class LLMContext(ContextBase):
    _execution_context: ExecutionContext

    def __init__(self, store: AgentContextStore, execution_context: ExecutionContext):
        super().__init__(store, execution_context)

    @staticmethod
    def from_context(context: ContextBase, monitored: Monitored) -> "LLMContext":
        return LLMContext(context._store, context._execution_context.new_for(monitored))

    @staticmethod
    def new_fake():
        return LLMContext(AgentContextStore(ChatHistory()), ExecutionContext())

    def new_for(self, monitored: Monitored) -> "LLMContext":
        return self.from_context(self, monitored)
