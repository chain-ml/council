from abc import ABC, abstractmethod
from enum import Enum
from typing import Any, Dict, List, Optional

from council.core.cancellation_token import CancellationToken
from council.utils import Option


class ChatMessageKind(str, Enum):
    """
    Enum representing the kinds or categories of chat messages within a chat system or application.
    """

    User = "USER"
    """
    Represents a chat message from the user.
    """

    Agent = "AGENT"
    """
    Represents a chat message from the agent or customer support representative.
    """

    System = "SYSTEM"
    """
    Represents a system-generated chat message.
    """

    Skill = "SKILL"
    """
    Represents a chat message generated by a specific skill or functionality within the chat system.
    """


class ChatMessageBase(ABC):
    """
    base class for chat messages.

    Attributes:
        message: a text message
        kind:the kind of message
    """

    message: str
    kind: ChatMessageKind

    def __init__(self, message: str, kind: ChatMessageKind):
        self.message = message
        self.kind = kind

    def is_of_kind(self, kind: ChatMessageKind) -> bool:
        return self.kind == kind

    def __str__(self):
        max_length = 50
        message = self.message[:max_length] + "..." if len(self.message) > max_length else self.message
        return f"Message of kind {self.kind}: {message}"


class UserMessage(ChatMessageBase):
    """
    a message from the user.

    Attributes:
        message: a text message
    """

    def __init__(self, message: str):
        super().__init__(message, ChatMessageKind.User)


class AgentMessage(ChatMessageBase):
    """
    a message generated from an :class:`~council.core.Agent`.

    Attributes:
        message: a text message
    """

    data: Any

    def __init__(self, message: str, data: Any):
        super().__init__(message, ChatMessageKind.Agent)
        self.data = data


class ScoredAgentMessage:
    """
    an :class:`AgentMessage` with a scored, as returned by an :class:`~.EvaluatorBase`

    Attributes:
        message (AgentMessage): an agent message
        score: a score reflecting the quality of the message
    """

    message: AgentMessage
    score: float

    def __init__(self, message: AgentMessage, score: float):
        self.message = message
        self.score = score


class SkillMessage(ChatMessageBase):
    """
    Base class for a message generated by a :class:`~.SkillBase`
    """

    _skill_name: str
    _data: Any

    def __init__(self, skill_name: str, message: str, data: Any = None):
        """
        Initialise a new instance.

        Arguments:
            skill_name (str): name of the skill
            message (str): a text message
            data (Any): optional data to enrich the message
        """

        super().__init__(message, ChatMessageKind.Skill)
        self._skill_name = skill_name
        self._data = data

    @abstractmethod
    def is_error(self) -> bool:
        """
        `True` if this is a :class:`~SkillErrorMessage`, otherwise `False`

        Returns:
            bool
        """
        pass

    @abstractmethod
    def is_ok(self) -> bool:
        """
        `True` if this is a :class:`SkillSuccessMessage`, otherwise `False`

        Returns:
            bool
        """
        pass

    @property
    def data(self) -> Any:
        """
        data related to the message

        Returns:
            Any
        """
        return self._data

    @property
    def from_skill(self) -> str:
        """
        the name of the :class:`.SkillBase` that has generated the message

        Returns:
            str
        """
        return self._skill_name

    def is_from_skill(self, skill_name: str) -> bool:
        """
        `True` is the message has been generated by the given :class:`.SkillBase`

        Arguments:
            skill_name (str): the skill name to check against

        Returns:
            bool
        """
        return self._skill_name == skill_name


class SkillSuccessMessage(SkillMessage):
    """
    a message generated by a :class:`.SkillBase` when executed successfully
    """

    def __init__(self, skill_name: str, message: str, data: Any = None):
        """
        initialize a new instance

        Parameters:
            skill_name (str): name of the :class:`.SkillBase` that generated the message.
            message (str): a text message.
            data (Any): optional data related to the message
        """
        super().__init__(skill_name=skill_name, message=message, data=data)

    def is_error(self) -> bool:
        return False

    def is_ok(self) -> bool:
        return True


class SkillErrorMessage(SkillMessage):
    """
    a message generated by a :class:`.SkillBase` when an error occurred
    """

    def __init__(self, skill_name: str, message: str, data: Any = None):
        """
        initialize a new instance

        Parameters:
            skill_name (str): name of the :class:`.SkillBase` that generated the message.
            message (str): a text message.
            data (Any): optional data related to the message
        """
        super().__init__(skill_name=skill_name, message=message, data=data)

    def is_ok(self) -> bool:
        return False

    def is_error(self) -> bool:
        return True


class ChatHistory:
    """
    represents the history of messages exchanged between the user and the :class:`~.Agent`

    Attributes:
        messages(list[ChatMessageBase]): list of messages
    """

    messages: List[ChatMessageBase] = []

    def __init__(self):
        """
        initialize a new instance
        """

        self.messages = []

    def add_user_message(self, message: str):
        """
        adds a :class:`UserMessage` into the history

        Arguments:
            message (str): a text message
        """

        self.messages.append(UserMessage(message))

    def last_user_message(self) -> Option[UserMessage]:
        """
        get the most recent user message in the history, if any.

        Returns:
            Option[UserMessage]: an :class:`council.utils.Option` with a user message, if any
        """
        for message in reversed(self.messages):
            if isinstance(message, UserMessage):
                return Option(message)
        return Option.none()

    def add_agent_message(self, message: str, data: Any = None):
        """
        adds a :class:`AgentMessage` into the history

        Arguments:
            message (str): a text message
            data (Any): some data, if any
        """

        self.messages.append(AgentMessage(message, data))

    def last_agent_message(self) -> Option[AgentMessage]:
        """
        get the most recent agent message in the history, if any.

        Returns:
            Option[AgentMessage]: an :class:`council.utils.Option` with an agent message, if any
        """

        for message in reversed(self.messages):
            if isinstance(message, AgentMessage):
                return Option(message)
        return Option.none()

    def last_message(self) -> Option[ChatMessageBase]:
        """
        get the most recent message in the history, if any.

        Returns:
            Option[ChatMessageBase]: an :class:`council.utils.Option` with an agent message, if any
        """

        return Option.none() if len(self.messages) == 0 else Option.some(self.messages[-1])

    @staticmethod
    def from_user_message(message: str) -> "ChatHistory":
        history = ChatHistory()
        history.add_user_message(message=message)
        return history


class ChainHistory:
    """
    Manages all the :class:`SkillMessage` generated during one execution of a :class:`.Chain`

    Attributes:
        messages (List[SkillMessage]): list of :class:`SkillMessage`
    """

    messages: List[SkillMessage]

    def __init__(self):
        """Initialize a new instance"""
        self.messages = []

    def last_message(self) -> Option[SkillMessage]:
        """
        Get the last (most recent) message, if any, added by a :class:`.SkillBase`

        Returns:
            Option[SkillMessage]: an :class:`council.utils.Option` wrapping a :class:`.SkillMessage` if any.
        """
        if len(self.messages) > 0:
            return Option(self.messages[-1])
        return Option.none()

    def last_message_from(self, skill: str) -> Option[SkillMessage]:
        """
        Get the last (most recent) message, if any, added by specific :class:`.SkillBase` identified by its name.

        Parameters:
            skill (str): the name of the skill
        Returns:
            Option[SkillMessage]: an :class:`council.utils.Option` wrapping a :class:`.SkillMessage` if any.
        """
        for message in self.messages[::-1]:
            if message.is_from_skill(skill):
                return Option(message)
        return Option.none()


class ChainContext:
    """
    Class representing the execution context of a :class:`.Chain`.

    Attributes:
        chatHistory (ChatHistory): The chat history.
        chainHistory (List[ChainHistory]): The chain iteration history for the chain.
    """

    chatHistory: ChatHistory
    chainHistory: List[ChainHistory]

    def __init__(self, chat_history: ChatHistory, chain_history: List[ChainHistory]):
        """
        Initializes the ChainContext with the provided chat and chain history.

        Args:
            chat_history (ChatHistory): The chat history.
            chain_history (List[ChainHistory]): All the :class:`ChainHistory` from the many execution of a chain.
        """
        self.chatHistory = chat_history
        self.chainHistory = chain_history
        self.cancellationToken = CancellationToken()

    def new_iteration(self):
        """
        Prepare this instance for a new execution of a chain by adding a new :class:`ChainHistory`
        """
        self.chainHistory.append(ChainHistory())

    @property
    def current(self) -> ChainHistory:
        """
        Returns the :class:`ChainHistory` to be used for the current execution of a :class:`.Chain`

        Returns:
            ChainHistory: the chain history
        """
        return self.chainHistory[-1]

    @property
    def last_message(self) -> Option[ChatMessageBase]:
        last_chain_message = self.current.last_message()
        if last_chain_message.is_none():
            return self.chatHistory.last_message()
        return Option.some(last_chain_message.unwrap())

    @staticmethod
    def empty() -> "ChainContext":
        history = ChatHistory()
        return ChainContext(history, [])

    @staticmethod
    def from_user_message(message: str) -> "ChainContext":
        history = ChatHistory.from_user_message(message)
        return ChainContext(history, [])


class IterationContext:
    """
    Provides context information when running inside a loop.
    """

    def __init__(self, index: int, value: Any):
        self._index = index
        self._value = value

    @property
    def index(self) -> int:
        """
        Returns the index of the current iteration

        Returns:
            int:
        """
        return self._index

    @property
    def value(self) -> Any:
        """
        Returns the value for the current iteration

        Returns:
            Any:
        """
        return self._value

    @staticmethod
    def empty() -> Option["IterationContext"]:
        return Option.none()

    @staticmethod
    def new(index: int, value: Any) -> Option["IterationContext"]:
        return Option.some(IterationContext(index, value))


class SkillContext(ChainContext):
    """
    Class representing the execution context of a :class:`.SkillBase`.
    """

    def __init__(self, chain_context: ChainContext, iteration: Option[IterationContext]):
        super().__init__(chain_context.chatHistory, chain_context.chainHistory)
        self._iteration = iteration

    @property
    def iteration(self) -> Option[IterationContext]:
        """
        The iteration context, if any.

        Returns:
            Option[IterationContext]: Some iteration context, if any, else :meth:`.Option.none`
        """
        return self._iteration


class AgentContext:
    """
    Class representing the execution context of an :class:`.Agent`.

    Attributes:
        chatHistory (ChatHistory): The chat history.
        chainHistory (Dict[str, List[ChainHistory]]): The chain history for each :class:`.Chain`.
        evaluationHistory (List[List[ScoredAgentMessage]]): The iteration history of evaluated agent messages.
    """

    chatHistory: ChatHistory
    chainHistory: Dict[str, List[ChainHistory]]
    evaluationHistory: List[List[ScoredAgentMessage]]

    def __init__(self, chat_history: ChatHistory):
        """
        Initializes the AgentContext with the provided chat history.

        Args:
            chat_history (ChatHistory): The chat history.
        """
        self.chatHistory = chat_history
        self.chainHistory: Dict[str, List[ChainHistory]] = {}
        self.evaluationHistory = []

    def new_chain_context(self, name: str) -> ChainContext:
        """
        Creates a new chain context for the specified chain name.

        Args:
            name (str): The name of the chain.

        Returns:
            ChainContext: The new chain context.
        """
        history = self.chainHistory.get(name)
        if history is None:
            history = []
            self.chainHistory[name] = history
        history.append(ChainHistory())
        return ChainContext(self.chatHistory, history)

    def last_evaluator_iteration(self) -> Optional[List[ScoredAgentMessage]]:
        """
        Retrieves the last iteration of the evaluator's history.

        Returns:
            Optional[List[ScoredAgentMessage]]: The last iteration of the evaluator's history,
                or None if the history is empty.
        """
        if len(self.evaluationHistory) == 0:
            return None
        return self.evaluationHistory[-1]

    def last_chain_history_iteration(self, chain_name: str) -> Optional[ChainHistory]:
        """
        Retrieves the last iteration of the specified chain's history.

        Args:
            chain_name (str): The name of the chain.

        Returns:
            Optional[ChainHistory]: The last iteration of the specified chain's history,
                or None if the history is empty.

        Raises:
            None
        """
        iterations: List[ChainHistory] = self.chainHistory[chain_name]
        if iterations is None or len(iterations) == 0:
            return None
        return iterations[-1]
